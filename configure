#!/usr/bin/env tclsh
namespace eval ::buildsys {
    namespace export build generate-makefile install uninstall
    namespace ensemble create

    variable cc cc
    variable packageDir tcl-duktape
    variable libraryFilename libtclduktape[info sharedlibextension]
    variable tclsh [info nameofexecutable]

    variable makefile {}
}

proc ::buildsys::generate-makefile {libInstallPath packageInstallPath} {
    variable libraryFilename
    variable makefile
    variable tclsh

    set makefile {}

    target all test
    target $libraryFilename [list \
            tcl-duktape.c \
            external/duktape.c \
            external/duktape.h \
            external/duk_config.h \
    ]
    build
    target test $libraryFilename
    command $tclsh tests.tcl
    target install $libraryFilename
    install $libInstallPath $packageInstallPath
    target uninstall
    uninstall $libInstallPath $packageInstallPath
    target clean
    command -rm $libraryFilename
    target .PHONY {all clean install test uninstall}
    return $makefile
}

proc ::buildsys::build {} {
    variable cc
    variable libraryFilename

    set tclFlags [list \
            -I[::tcl::pkgconfig get includedir,runtime] \
            -L[::tcl::pkgconfig get libdir,runtime] \
    ]
    command $cc -Wall external/duktape.c -shared -o $libraryFilename \
            -fPIC {*}$tclFlags tcl-duktape.c
}

proc ::buildsys::install {libInstallPath packageInstallPath} {
    variable libraryFilename

    command mkdir -p $packageInstallPath
    copy-to $libInstallPath $libraryFilename
    if {$libInstallPath eq $packageInstallPath} {
        # Installing to a custom destination.
        set pkgFile pkgIndex.tcl
    } else {
        set pkgFile pkgIndex-libdir.tcl
    }
    copy-to $packageInstallPath \
            [list $pkgFile pkgIndex.tcl] \
            oo.tcl \
            utils.tcl
}

proc ::buildsys::uninstall {libInstallPath packageInstallPath} {
    variable libraryFilename

    delete-in $libInstallPath $libraryFilename
    delete-in $packageInstallPath pkgIndex.tcl oo.tcl utils.tcl
    command rmdir $packageInstallPath
}

proc ::buildsys::parse-options argv {
    if {[llength $argv] % 2 == 1} {
        error "the arguments should be a dictionary (\"$argv\" given)"
    }
    if {[dict exists $argv -destdir]} {
        set customInstallPath [dict get $argv -destdir]
        dict unset argv -destdir
    } else {
        set customInstallPath {}
    }
    if {[dict size $argv] > 0} {
        error "unknown options: $argv; should be\
                \"[dict get [info frame 0] proc] ?-destdir PATH?\""
    }

    return $customInstallPath
}

proc ::buildsys::main {argv0 argv} {
    variable makefile
    variable packageDir

    cd [file dirname [file dirname [file normalize $argv0/___]]]

    set customInstallPath [parse-options $argv]
    if {$customInstallPath eq {}} {
        set libInstallPath [::tcl::pkgconfig get libdir,runtime]
        set packageInstallPath \
                [file join [::tcl::pkgconfig get scriptdir,runtime] \
                        $packageDir]
    } else {
        set libInstallPath $customInstallPath
        set packageInstallPath $customInstallPath
    }

    puts "[file tail [info script]]: creating Makefile"
    set makefile [generate-makefile $libInstallPath $packageInstallPath]

    set ch [open Makefile w]
    puts -nonewline $ch $makefile
    close $ch
}

# Utility procs.

proc ::buildsys::target {name {deps {}}} {
    variable makefile
    append makefile "$name: [join $deps]\n"
}

proc ::buildsys::quote s {
    if {[regexp {[^a-zA-Z0-9_./-]} $s]} {
        # Quote $arg and escape any single quotes in it.
        set result '[string map {' '"'"' $ $$} $s]'
    } else {
        set result $s
    }
    return $result
}

proc ::buildsys::command args {
    variable makefile
    set quotedArgs {}
    foreach arg $args {
        lappend quotedArgs [quote $arg]
    }
    command-raw {*}$quotedArgs
}

proc ::buildsys::command-raw args {
    variable makefile
    append makefile \t[join $args]\n
}

# Emit the commands to copy the files in the list $args to $destDir. Each
# element in $args can be either a filename or a list of the format
# {sourceFilename destFilename}.
proc ::buildsys::copy-to {destDir args} {
    foreach file $args {
        lassign $file sourceFilename destFilename
        command cp $sourceFilename [file join $destDir $destFilename]
    }
}

# Emit the command(s) to delete the given file(s) under $path.
proc ::buildsys::delete-in {path args} {
    foreach file $args {
        command -rm [file join $path $file]
    }
}

# If this is the main script...
if {[info exists argv0] && ([file tail [info script]] eq [file tail $argv0])} {
    ::buildsys::main $argv0 $argv
}
