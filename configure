#!/usr/bin/env tclsh
# tcl-duktape Makefile generator.
# Copyright (c) 2015, 2016, 2017, 2018
# dbohdan and contributors listed in AUTHORS
# This code is released under the terms of the MIT license. See the file
# LICENSE for details.

namespace eval ::buildsys {
    namespace export build generate-makefile install uninstall
    namespace ensemble create

    proc env {key default} {
        return [expr {[info exists ::env($key)] ? $::env($key) : $default}]
    }

    variable config [dict create \
        cc           [env CC cc] \
        ccFlags      [env CFLAGS {}] \
        destDir      {} \
        includeDir   [::tcl::pkgconfig get includedir,runtime] \
        libDir       [::tcl::pkgconfig get libdir,runtime] \
        packageDest  [file join [::tcl::pkgconfig get scriptdir,runtime] \
                                tcl-duktape] \
        libDest      [::tcl::pkgconfig get libdir,runtime] \
        libraryFile  lib/libtclduktape[info sharedlibextension] \
        tclsh        [info nameofexecutable] \
    ]

    rename env {}
}


### Pure functions for generating fragments of the Makefile

proc ::buildsys::generate-makefile config {
    dict with config {}

    set pkgIndexFile lib/pkgIndex-libdir.tcl
    # Are we installing to a custom destination?
    if {$destDir ne {}} {
        set libDest $destDir
        set packageDest $destDir
        set pkgIndexFile lib/pkgIndex.tcl
    }

    set makefile [join [sl {
        target all : test

        ----
        target $libraryFile : lib/tcl-duktape.c \
                              vendor/duktape/duktape.c \
                              vendor/duktape/duktape.h \
                              vendor/duktape/duk_config.h
        command $cc vendor/duktape/duktape.c \
                    -o $libraryFile \
                    -Wall \
                    -shared \
                    -fPIC \
                    -I$includeDir \
                    -L$libDir \
                    {*}$ccFlags \
                    lib/tcl-duktape.c

        ----
        target test : $libraryFile
        command $tclsh tests.tcl

        ----
        target install : $libraryFile
        command mkdir -p $packageDest
        copy-to $libDest $libraryFile
        copy-to $packageDest \
                [list $pkgIndexFile pkgIndex.tcl] \
                lib/oo.tcl \
                lib/utils.tcl

        ----
        target uninstall
        delete-in $libDest [file tail $libraryFile]
        delete-in $packageDest pkgIndex.tcl oo.tcl utils.tcl
        command rmdir $packageDest

        ----
        target clean
        command -rm $libraryFile

        ----
        target .PHONY : all clean install test uninstall
    }] {}]

    return $makefile
}

proc ::buildsys::target {name {colon {}} args} {
    if {$args ne {} && $colon ne {:}} {
        error "expected a \":\", but got \"$colon\""
    }
    return "$name: [join $args]\n"
}

proc ::buildsys::quote s {
    set result $s
    if {[regexp {[^a-zA-Z0-9_./-]} $s]} {
        # Quote $arg and escape any single quotes in it.
        set result '[string map {' '"'"' $ $$} $s]'
    }
    return $result
}

proc ::buildsys::---- {} {
    return \n
}

proc ::buildsys::command args {
    set quotedArgs {}
    foreach arg $args {
        lappend quotedArgs [quote $arg]
    }
    return [command-raw {*}$quotedArgs]
}

proc ::buildsys::command-raw args {
    return \t[join $args]\n
}

# Return the commands to copy the files in the list $args to $dest. Each
# element in $args must be a list of one of two formats: {sourceFile} or
# {sourceFile destFile}.
proc ::buildsys::copy-to {dest args} {
    set result {}
    foreach file $args {
        switch [llength $file] {
            1 {
                lassign $file sourceFile
                set destFile [file tail $sourceFile]
            }
            2 {
                lassign $file sourceFile destFile
            }
            default {
                error "expected a list of one or two elements,\
                       but got [list $file]"
            }
        }
        lappend result [command cp $sourceFile \
                                   [file join $dest $destFile]]
    }
    return [join $result {}]
}

# Return the commands to delete in the directory $path each of the files listed
# in $args.
proc ::buildsys::delete-in {path args} {
    set result {}
    foreach file $args {
        lappend result [command -rm [file join $path $file]]
    }
    return [join $result {}]
}


### Script startup and configuration; file output

# Parse the command line arguments.
proc ::buildsys::parse-options {argv0 argv} {
    set usage "Usage: $argv0 \[--destdir PATH\] \[--includedir PATH\]\
               \[--libdir PATH\]\n\n"
    append usage "This script also uses the value of the\
                  environment variables CC and CFLAGS."

    if {$argv in {-h -help --help}} {
        puts $usage
        exit 0
    }
    if {[llength $argv] % 2 == 1} {
        puts "Error: Can't parse the command line arguments (\"$argv\").\
              Expected an even number of arguments (a Tcl dictionary)."
        exit 1
    }

    set options {}
    foreach {flag key} {
        --includedir   includeDir
        --libdir       libDir
        --destdir      destDir
    } {
        if {[dict exists $argv $flag]} {
            dict set options $key [dict get $argv $flag]
            dict unset argv $flag
        }
    }

    if {[dict size $argv] > 0} {
        puts "Unknown option(s): \"[join $argv {", "}]\"."
        exit 1
    }

    return $options
}

proc ::buildsys::main {argv0 argv} {
    variable config

    cd [file dirname [file dirname [file normalize $argv0/___]]]
    source vendor/sl/sl.tcl
    namespace path ::sl

    set options [parse-options $argv0 $argv]
    set config [dict merge $config $options]

    puts "[file tail [info script]]: creating Makefile"
    set makefile [generate-makefile $config]

    set ch [open Makefile w]
    puts -nonewline $ch $makefile
    close $ch
}

# If this is the main script...
if {[info exists argv0] && ([file tail [info script]] eq [file tail $argv0])} {
    ::buildsys::main $argv0 $argv
}
